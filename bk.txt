fn render_chunks(
        mut commands: Commands,
        mut meshes: ResMut<Assets<Mesh>>, 
        mut materials: ResMut<Assets<StandardMaterial>>,        
        player_query: Query<&Transform, With<Player>>,
        chunk_query: Query<(Entity, &Chunk, &Transform)>,
    ) {
        let player_transform = player_query.single();
        let x: isize = player_transform.translation[0] as isize / 8;
        let y: isize = player_transform.translation[1] as isize / 8;
        let z: isize = player_transform.translation[2] as isize / 8;

        let mut voxel_world = VoxelWorld::new();

        //println!("{x}, {y}, {z}");
        for i in (x - 3)..(x + 3) {
            for j in (y - 3)..(y + 3) {
                for k in (z- 3)..(z + 3) {
                    voxel_world.set_voxel(i as i32, j as i32, k as i32, true);
                    let mut exists = false;

                    for (chunk_entity, chunk, transform) in chunk_query.iter() {
                        let chunk_pos = transform.translation;
                        
                        if (chunk_pos.x as i32 == i as i32) && (chunk_pos.y as i32 == j as i32) && (chunk_pos.z as i32 == k as i32) {
                            exists = true;
                        }  
                    }
                    if !exists {
                        println!("Shouldnt happen much!");
                        let chunk_entity = commands.spawn((
                        Chunk {
                            position: Vec3::new(i as f32, j as f32, k as f32),
                        },
                            SpatialBundle {..default()}
                        )).id();


                        for a in 0..15 {
                            for b in 0..15 {
                                for c in 0..15 {
                                    let perlin = Perlin::new(1);
                                    let scale = 0.2;

                                    if perlin.get([i as f64 * scale, j as f64 * scale, k as f64 * scale]) >= 0.0 {
                                        let cube = commands.spawn((
                                                PbrBundle {
                                                    mesh: meshes.add(Cuboid::new(1.0, 1.0, 1.0)),
                                                    transform: Transform::from_xyz(
                                                        a as f32 + i as f32 - 7.0,
                                                        b as f32 + j as f32 - 7.0,
                                                        c as f32 + k as f32 - 7.0,
                                                        ),
                                                    material: materials.add(Color::WHITE),
                                                    ..default()
                                                }, Cube)).id();
                                        commands.entity(chunk_entity).push_children(&[cube]);
                                    };
                                }
                            }
                        }

                    }
                }

            }
        }
         
        for (chunk_entity, chunk, transform) in chunk_query.iter() {
            let chunk_pos = transform.translation;
            
            if voxel_world.get_voxel(chunk_pos.x as i32, chunk_pos.y as i32, chunk_pos.z as i32) == Some(&false) {
                commands.entity(chunk_entity).despawn_recursive();
                println!("DESPAWN -> {x}, {y}, {z}")
            }    
        } 
}
